
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.21.0";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  const supabaseUrl = Deno.env.get('SUPABASE_URL') || '';
  const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') || '';
  
  const supabase = createClient(supabaseUrl, supabaseServiceKey);

  try {
    // Fetch the RSS feed
    const response = await fetch("https://cvefeed.io/rssfeed/latest.xml");
    
    if (!response.ok) {
      throw new Error(`Failed to fetch RSS feed: ${response.status} ${response.statusText}`);
    }
    
    const xml = await response.text();
    console.log("Received XML content, length:", xml.length);
    
    // Instead of using DOMParser (which is causing issues), use a simple regex-based approach
    // to extract CVE data from the XML
    const cveEntries = [];
    const itemRegex = /<item>([\s\S]*?)<\/item>/g;
    const titleRegex = /<title>(.*?)<\/title>/;
    const linkRegex = /<link>(.*?)<\/link>/;
    const descRegex = /<description>(.*?)<\/description>/;
    const pubDateRegex = /<pubDate>(.*?)<\/pubDate>/;
    const cveIdRegex = /CVE-\d{4}-\d+/;
    
    let itemMatch;
    while ((itemMatch = itemRegex.exec(xml)) !== null) {
      const itemContent = itemMatch[1];
      
      // Extract title
      const titleMatch = titleRegex.exec(itemContent);
      const title = titleMatch ? titleMatch[1] : "";
      
      // Extract link
      const linkMatch = linkRegex.exec(itemContent);
      const link = linkMatch ? linkMatch[1] : "";
      
      // Extract description
      const descMatch = descRegex.exec(itemContent);
      const description = descMatch ? descMatch[1] : "";
      
      // Extract pubDate
      const pubDateMatch = pubDateRegex.exec(itemContent);
      const pubDate = pubDateMatch ? pubDateMatch[1] : "";
      
      // Extract CVE ID from title or description
      const cveIdMatchTitle = title.match(cveIdRegex);
      const cveIdMatchDesc = description.match(cveIdRegex);
      const cveId = cveIdMatchTitle || cveIdMatchDesc ? (cveIdMatchTitle || cveIdMatchDesc)[0] : null;
      
      // Sanitize or decode HTML entities if needed
      const sanitizedTitle = title.replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&amp;/g, '&');
      const sanitizedDescription = description.replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&amp;/g, '&');
      
      // Create vulnerability object - using the correct field names that match our database schema
      const vulnerability = {
        title: sanitizedTitle,
        description: sanitizedDescription,
        // Remove cve_id field since it doesn't exist in our schema
        source_url: link,
        severity: null, // To be filled by AI enrichment
        risk_rating: null, // To be filled by AI enrichment
        technical_impact: null, // To be filled by AI enrichment
        business_impact: null, // To be filled by AI enrichment
        is_vulnerable: true,
        created_at: new Date(pubDate).toISOString(),
        updated_at: new Date().toISOString()
      };
      
      cveEntries.push(vulnerability);
    }
    
    console.log(`Parsed ${cveEntries.length} CVE entries from XML`);
    
    // Insert the entries into the vulnerabilities table
    if (cveEntries.length > 0) {
      const { data, error } = await supabase
        .from('vulnerabilities')
        .insert(cveEntries);
      
      if (error) {
        console.error("Error inserting CVE entries:", error);
        throw error;
      }
      
      console.log(`Successfully inserted ${cveEntries.length} CVE entries into the database`);
    }
    
    return new Response(
      JSON.stringify({ 
        success: true, 
        message: `正常に ${cveEntries.length} 件の CVE エントリーをフェッチしました`,
        count: cveEntries.length
      }),
      { 
        headers: { 
          ...corsHeaders, 
          "Content-Type": "application/json" 
        } 
      }
    );
    
  } catch (error) {
    console.error("Error fetching CVE data:", error);
    
    return new Response(
      JSON.stringify({ 
        success: false, 
        message: `CVE データの取得に失敗しました: ${error.message}` 
      }),
      { 
        status: 500,
        headers: { 
          ...corsHeaders, 
          "Content-Type": "application/json" 
        } 
      }
    );
  }
});
