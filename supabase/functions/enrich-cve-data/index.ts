
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.21.0";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  const supabaseUrl = Deno.env.get('SUPABASE_URL') || '';
  const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') || '';
  
  const supabase = createClient(supabaseUrl, supabaseServiceKey);

  try {
    // Fetch unenriched vulnerabilities (those without technical_impact)
    const { data: unenrichedData, error: fetchError } = await supabase
      .from('vulnerabilities')
      .select('*')
      .is('technical_impact', null)
      .limit(10); // Process in batches
    
    if (fetchError) throw fetchError;
    
    if (!unenrichedData || unenrichedData.length === 0) {
      return new Response(
        JSON.stringify({ 
          success: true, 
          message: "処理が必要なエントリーはありません",
          count: 0,
          processed: []
        }),
        { 
          headers: { 
            ...corsHeaders, 
            "Content-Type": "application/json" 
          } 
        }
      );
    }
    
    console.log(`Found ${unenrichedData.length} unenriched vulnerability entries`);
    
    // Process each vulnerability
    const processResults = [];
    
    for (const vuln of unenrichedData) {
      try {
        // In a real implementation, this would call OpenAI API
        // For now, we'll simulate the enrichment with placeholder data
        const enrichedData = simulateAIEnrichment(vuln);
        
        // Update the vulnerability with enriched data
        const { error: updateError } = await supabase
          .from('vulnerabilities')
          .update(enrichedData)
          .eq('id', vuln.id);
        
        if (updateError) throw updateError;
        
        processResults.push({
          id: vuln.id,
          title: vuln.title,
          cve_id: vuln.cve_id || "Unknown CVE",
          status: "success"
        });
        
        console.log(`Successfully enriched vulnerability: ${vuln.title}`);
      } catch (error) {
        console.error(`Error processing vulnerability ${vuln.id}:`, error);
        processResults.push({
          id: vuln.id,
          title: vuln.title,
          cve_id: vuln.cve_id || "Unknown CVE",
          status: "failed",
          error: error.message
        });
      }
    }
    
    return new Response(
      JSON.stringify({ 
        success: true, 
        message: `${processResults.length} 件の脆弱性エントリーが処理されました`,
        count: processResults.length,
        processed: processResults
      }),
      { 
        headers: { 
          ...corsHeaders, 
          "Content-Type": "application/json" 
        } 
      }
    );
    
  } catch (error) {
    console.error("Error enriching CVE data:", error);
    
    return new Response(
      JSON.stringify({ 
        success: false, 
        message: `CVE データの強化に失敗しました: ${error.message}` 
      }),
      { 
        status: 500,
        headers: { 
          ...corsHeaders, 
          "Content-Type": "application/json" 
        } 
      }
    );
  }
});

// Function to simulate AI enrichment
function simulateAIEnrichment(vulnerability) {
  // Extract potential affected systems from the description
  const affectedProductsMatch = vulnerability.description?.match(/affects (.*?)(?:\.|\,)/i);
  const affectedProducts = affectedProductsMatch 
    ? [affectedProductsMatch[1]] 
    : generateRandomAffectedProducts();

  // Determine CVE severity based on content
  const hasKeywords = (text, keywords) => {
    if (!text) return false;
    return keywords.some(keyword => text.toLowerCase().includes(keyword));
  };
  
  const criticalKeywords = ['critical', 'remote code execution', 'arbitrary code', 'unauthenticated'];
  const highKeywords = ['high', 'sql injection', 'xss', 'cross-site', 'buffer overflow'];
  const mediumKeywords = ['medium', 'information disclosure', 'denial of service'];
  
  let severity = "low";
  let cvssScore = 3.5;
  
  if (hasKeywords(vulnerability.title + vulnerability.description, criticalKeywords)) {
    severity = "critical";
    cvssScore = 8.5 + Math.random() * 1.5; // 8.5-10.0
  } else if (hasKeywords(vulnerability.title + vulnerability.description, highKeywords)) {
    severity = "high";
    cvssScore = 7.0 + Math.random() * 1.5; // 7.0-8.5
  } else if (hasKeywords(vulnerability.title + vulnerability.description, mediumKeywords)) {
    severity = "medium";
    cvssScore = 4.0 + Math.random() * 3.0; // 4.0-7.0
  } else {
    cvssScore = 1.0 + Math.random() * 3.0; // 1.0-4.0
  }
  
  cvssScore = Math.round(cvssScore * 10) / 10; // Round to 1 decimal place
  
  // Risk ratings are critical, high, medium, low
  const riskRating = severity;

  // Determine exploit status based on CVE ID or description
  const hasExploit = Math.random() > 0.7; // 30% chance of having known exploits
  const exploitInfo = hasExploit 
    ? "Proof-of-concept exploit code is available. Active exploitation observed in the wild." 
    : "No known exploits at this time.";
    
  // Generate technical impact
  const technicalImpactOptions = {
    critical: [
      "Remote code execution allows attackers to gain full control of affected systems.",
      "Complete system compromise possible through unauthenticated access.",
      "Arbitrary command execution with system privileges.",
    ],
    high: [
      "Sensitive data exposure including potential access to authentication credentials.",
      "SQL injection allowing unauthorized database access.",
      "Memory corruption leading to crash or potential code execution.",
    ],
    medium: [
      "Cross-site scripting allowing session hijacking.",
      "Denial of service affecting application availability.",
      "Information disclosure revealing system configuration details.",
    ],
    low: [
      "Minor information disclosure not exposing sensitive data.",
      "Local-only exploit requiring physical access.",
      "Limited impact requiring extensive user interaction.",
    ]
  };

  const randomImpact = options => options[Math.floor(Math.random() * options.length)];
  const technicalImpact = randomImpact(technicalImpactOptions[severity]);
  
  // Generate business impact
  const businessImpactOptions = {
    critical: [
      "Critical business disruption with potential for significant financial loss and reputational damage.",
      "Severe regulatory compliance violations resulting in potential fines and sanctions.",
      "Complete compromise of sensitive customer data requiring mandatory breach reporting.",
    ],
    high: [
      "Significant operational disruption affecting key business services.",
      "Partial data breach with moderate financial and reputational impact.",
      "Compliance issues requiring remediation and potential reporting.",
    ],
    medium: [
      "Moderate service disruption affecting non-critical systems.",
      "Limited unauthorized access with minimal sensitive data exposure.",
      "Minor compliance issues requiring internal documentation.",
    ],
    low: [
      "Minimal business impact with no service disruption.",
      "No sensitive data exposure or compliance implications.",
      "Negligible financial or reputational risk.",
    ]
  };

  const businessImpact = randomImpact(businessImpactOptions[severity]);

  return {
    ...vulnerability,
    severity: severity,
    risk_rating: riskRating,
    cvss_score: cvssScore,
    technical_impact: technicalImpact,
    business_impact: businessImpact,
    exploit_status: exploitInfo,
    affected_products: affectedProducts,
    updated_at: new Date().toISOString()
  };
}

function generateRandomAffectedProducts() {
  const products = [
    "Apache Server 2.4.x", 
    "Windows 10", 
    "Ubuntu 20.04 LTS", 
    "Nginx 1.18.0", 
    "MySQL 8.0", 
    "WordPress 5.9",
    "PHP 7.4",
    "Docker 20.10",
    "VMware ESXi 7.0",
    "Kubernetes 1.23",
    "Cisco IOS XE",
    "Microsoft Exchange Server",
    "Jenkins CI",
    "JBoss Application Server",
    "SAP NetWeaver"
  ];
  
  const count = 1 + Math.floor(Math.random() * 3); // 1-3 products
  const selected = [];
  
  for (let i = 0; i < count; i++) {
    const product = products[Math.floor(Math.random() * products.length)];
    if (!selected.includes(product)) {
      selected.push(product);
    }
  }
  
  return selected;
}
